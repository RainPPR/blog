# 动态规划基础

动态规划（Dynamic Programming，DP）是一种解决问题的思想，而不是具体的算法。

## 概念和思路

我们在问题中用简单的信息描述一个局部的子问题，称为**状态**。

问题的限制具有一定的局部性，于是我们可以用简单的转移将子问题连接起来。

通过这个过程，进而得到原问题的答案，称为**转移**。

动态规划就是这种，将问题分解为若干个相对简单的**子问题**的思想。

大多数动态规划的关键在于，找到**合适的状态**，通过**合适的转移**得到所有子问题的结果。

状态设计需要注意的点：在子问题中，当前记录的状态是不是足够处理问题的限制？

转移设计需要注意的点：是否不重不漏（计数）？是否找到了最优解（最优化）？

一个问题如果满足无后效性，那么大概率可以使用动态规划解决。

我们按照一定的顺序求解，最终即可得到答案。

!!! note "关于闫氏 DP 分析法"
    以下是个人见解。

    闫氏 DP 分析法认为，动态规划的本质就是状态表示和状态计算。

    对于状态表示，我们令一个 $f(\dots)$ 表示满足某个条件的所有元素的集合的某种属性。

    例如：我们令 $f(i,j)$ 表示 $[l,r]$ 的每一个元素（集合）的最小值（属性）。

    对于状态计算，我们将集合分为若干个子集，且每个元素仅出现一次（不重不漏）。

    我们在能求出答案的情况下，要求维度越小越好，一般可以只考虑上一步的分类。

    那么，动态规划的时间复杂度就是状态数量乘以转移复杂度。

## 分类

#### 按照状态分类

+ 序列 DP
    + 线性 DP
    + 区间 DP
+ 状压 DP
    + 子集 DP
    + 轮廓线 DP
    + 插头 DP
+ 树形 DP
    + DAG DP
    + 换根 DP
    + 树形背包

#### 按照目的分类

+ 背包 DP
+ 数学相关
    + 数位 DP
    + 计数 DP
    + 概率 DP
    + 期望 DP

#### 一些优化方法

+ 状态设计优化
+ 数据结构优化
    + bitset 优化
    + 单调数据结构优化
    + 线段树优化
    + 平衡树优化
    + 动态 DP
+ wqs 二分
+ 矩阵乘法优化
+ 四边形不等式、决策单调性、斜率优化

## DFS、贪心、DP

### 关系

一般来说，从贪心，到 DP，到搜索，是判断某种条件越来越难。

因此，贪心解决的问题可以 DP 解决，DP 解决的问题可以搜索解决。

### 记忆化搜索

动态规划本身就是一种类似暴力的方法，但是对于大量重叠的子问题，动态规划会复用状态。

因此，如果我们在暴力搜索的时候加上复用状态，即记忆化搜索。

记忆化搜索一般可以优化到和动态规划一样的复杂度，但是由于递归本身常熟较大。

但是，如果如果很多状态是无用的、不会被转移到，那么记忆化搜索也会更快。

用记忆化搜索实现动态规划思路更加清晰，例如数位 DP 的时候就会大量使用记忆化搜索。

#### 记忆化

使用 `mem` 数组表示记忆化的结果，我们一般初始化为 $-1$ 表示未被搜索到。

```delphi
function dfs(...)
    if mem[...] != -1:
        return mem[...]
    ans = ...
    return mem[...] = ans
```

有时一些状态不会被重复利用，那么可以将这些状态不记录，

```delphi
function dfs(valid, ...)
    if valid and mem[...] != -1:
        return mem[...]
    ans = ...
    if valid:
        mem[...] = ans
    return ans
```

我们一般有两种方法来写记忆化搜索。

#### 方法一

1. 写出状态转移方程；

2. 根据转移方程写出 DFS 函数；

3. 添加记忆化。

#### 方法二

1. 写出暴搜 DFS 程序；

2. 修改为传入所有状态，与外部变量无关的递归；

3. 添加记忆化。